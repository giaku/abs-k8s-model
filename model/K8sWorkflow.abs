module K8sWorkflow;

export *;

import * from K8sService;
import * from K8sUtil;

/*import * from ABS.DC;

import * from K8sUtil;
import * from ABS.Scheduler;*/



interface ServiceTask{
  Rat execute();
}
class ServiceRequest(ServiceEndpoint se, Request request) implements ServiceTask{
  Rat execute(){
    Rat responseTimeDelay = await se!invokeService(request);

    return responseTimeDelay;
  }
}
class ServiceWorkflow(List<List<ServiceTask>> tasks, Rat workflowBaseline, PolyFunction pf) implements ServiceTask{
  Rat execute(){
    Rat totalRtDelay = 0;
    List<Fut<Rat>> timeFuts = list[];

    foreach (tList in tasks){
      Fut<Rat> timeFut = this!executeParallel(tList);
      timeFuts = appendright(timeFuts,timeFut);
    }

    foreach (tf in timeFuts){
      await tf?;
      Rat t = tf.get;
      if (t > totalRtDelay){
        totalRtDelay = t;
      }
    }

    // compute baseline response time + delay caused response time
    Rat responseTime = workflowBaseline + rat(polFuncEval(pf,float(totalRtDelay)));
    println("WORKFLOW_BASELINE: " + toString(workflowBaseline) + "  CONSUMPTION_DELAY_RT: " + toString(polFuncEval(pf,float(totalRtDelay)))
            + "  DELAY_TU: " + toString(float(totalRtDelay)));

    return responseTime;
  }
  Rat executeParallel(List<ServiceTask> list){
    Rat rTime = 0;
    List<Fut<Rat>> timeFuts = list[];

    foreach (task in list){
      Fut<Rat> timeFut = task!execute();
      timeFuts = appendright(timeFuts,timeFut);
    }

    foreach (tf in timeFuts){
      await tf?;
      Rat t = tf.get;
      if (t > rTime){
        rTime = t;
      }
    }

    return rTime;
  }
}
